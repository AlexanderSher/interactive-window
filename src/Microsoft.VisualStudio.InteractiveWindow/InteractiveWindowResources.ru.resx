<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AlreadyInitialized" xml:space="preserve">
    <value>Интерактивное окно уже было инициализировано.</value>
  </data>
  <data name="AltDownArrowHelp" xml:space="preserve">
    <value>Замена текущей отправки на последующую (после предыдущего перехода в обратном порядке).</value>
  </data>
  <data name="AltUpArrowHelp" xml:space="preserve">
    <value>Замена текущей отправки на предыдущую.</value>
  </data>
  <data name="ClearScreenCommandDescription" xml:space="preserve">
    <value>Удаление содержимого окна редактирования, не затрагивая журнал и контекст выполнения.</value>
  </data>
  <data name="CommandFailed" xml:space="preserve">
    <value>Команда "{0}" не выполнена: {1}</value>
  </data>
  <data name="CommandNamePlaceholder" xml:space="preserve">
    <value>[имя_команды]</value>
  </data>
  <data name="CtrlAHelp" xml:space="preserve">
    <value>Первое нажатие выделяет отправку, в которой находится курсор. Второе нажатие выделяет весь текст в окне.</value>
  </data>
  <data name="CtrlAltDownArrowHelp" xml:space="preserve">
    <value>Замена текущей отправки на последующую, начинающуюся с того же текста (после предыдущего перехода в обратном порядке).</value>
  </data>
  <data name="CtrlAltUpArrowHelp" xml:space="preserve">
    <value>Замена текущей отправки на предыдущую, начинающуюся с того же текста.</value>
  </data>
  <data name="CtrlECtrlEnterHelp" xml:space="preserve">
    <value>Вставка и выполнение выбранного перед любым ожидающим вводом в интерактивном буфере.</value>
  </data>
  <data name="CtrlEnterHelp1" xml:space="preserve">
    <value>Вычисление текущей отправки в рамках текущей отправки.</value>
  </data>
  <data name="CtrlEnterHelp2" xml:space="preserve">
    <value>Добавление предыдущей отправки к текущей в рамках предыдущей отправки.</value>
  </data>
  <data name="CtrlKCtrlEnterHelp" xml:space="preserve">
    <value>Вставка выбранного в конец интерактивного буфера, при этом курсор остается в конце ввода.</value>
  </data>
  <data name="DownArrowHelp1" xml:space="preserve">
    <value>Замена текущей отправки на последующую в конце текущей отправки (после предыдущего перехода в обратном порядке).</value>
  </data>
  <data name="DownArrowHelp2" xml:space="preserve">
    <value>В других случаях курсор перемещается на строку ниже.</value>
  </data>
  <data name="DuplicateCommand" xml:space="preserve">
    <value>Команда с именем "{0}" уже зарегистрирована.</value>
  </data>
  <data name="EnterHelp" xml:space="preserve">
    <value>Вычисление текущей отправки, если она выполнена. В противном случае вставляет новую строку.</value>
  </data>
  <data name="EscapeHelp" xml:space="preserve">
    <value>Удаление текущей отправки.</value>
  </data>
  <data name="HelpCommandDescription" xml:space="preserve">
    <value>Отображение справки по выбранной команде или по всем доступным командам и сочетаниям клавиш, если конкретная команда не указана.</value>
  </data>
  <data name="InternalError" xml:space="preserve">
    <value>В интерактивном окне произошла внутренняя ошибка. Перезапустите Visual Studio.</value>
  </data>
  <data name="KeyboardShortcuts" xml:space="preserve">
    <value>Сочетания клавиш:</value>
  </data>
  <data name="MissingCommandName" xml:space="preserve">
    <value>Команда типа "{0}" не включает имена команд.</value>
  </data>
  <data name="NotInitialized" xml:space="preserve">
    <value>Интерактивное окно еще не инициализировано.</value>
  </data>
  <data name="IsResetting" xml:space="preserve">
    <value>Выполняется сброс интерактивного окна.</value>
  </data>
  <data name="Parameters" xml:space="preserve">
    <value>Параметры:</value>
  </data>
  <data name="ReplCommands" xml:space="preserve">
    <value>Команды цикла чтение-вычисление-печать (REPL):</value>
  </data>
  <data name="RequireNonUIThread" xml:space="preserve">
    <value>Этот метод нельзя вызвать в потоке пользовательского интерфейса (во избежание зависаний).</value>
  </data>
  <data name="RequireUIThread" xml:space="preserve">
    <value>Этот метод можно вызвать только в потоке пользовательского интерфейса.</value>
  </data>
  <data name="ResetCommandDescription" xml:space="preserve">
    <value>Сброс окружения выполнения до первоначального состояния с сохранением журнала.</value>
  </data>
  <data name="ResetCommandParametersDescription" xml:space="preserve">
    <value>Сброс до состояния чистого окружения (есть только ссылка на mscorlib) без запуска скрипта инициализации.</value>
  </data>
  <data name="ShiftEnterHelp" xml:space="preserve">
    <value>Вставка новой строки.</value>
  </data>
  <data name="UnknownCommand" xml:space="preserve">
    <value>Неизвестная команда "{0}".</value>
  </data>
  <data name="UpArrowHelp1" xml:space="preserve">
    <value>Замена текущей отправки на предыдущую в конце текущей отправки.</value>
  </data>
  <data name="UpArrowHelp2" xml:space="preserve">
    <value>В других случаях курсор перемещается на строку выше.</value>
  </data>
  <data name="Usage" xml:space="preserve">
    <value>Использование:</value>
  </data>
  <data name="WaitTitle" xml:space="preserve">
    <value>Копировать</value>
  </data>
  <data name="WaitMessage" xml:space="preserve">
    <value>Создание представления RTF из выделенных элементов.</value>
  </data>
  <data name="Backspace" xml:space="preserve">
    <value>Удалить знак слева</value>
  </data>
  <data name="BreakLine" xml:space="preserve">
    <value>Вставить новую строку</value>
  </data>
  <data name="Paste" xml:space="preserve">
    <value>Вставить</value>
  </data>
  <data name="Cut" xml:space="preserve">
    <value>Вырезать выделенный фрагмент</value>
  </data>
  <data name="Delete" xml:space="preserve">
    <value>Удалить текст</value>
  </data>
  <data name="CutLine" xml:space="preserve">
    <value>Вырезать строку</value>
  </data>
  <data name="DeleteLine" xml:space="preserve">
    <value>Удалить строку</value>
  </data>
  <data name="TypeChar" xml:space="preserve">
    <value>Вставить текст</value>
  </data>
  <data name="CSVBScriptDirectives" xml:space="preserve">
    <value>Директивы скрипта:</value>
  </data>
  <data name="RefHelp" xml:space="preserve">
    <value>Добавьте ссылку на метаданные, чтобы указать сборку и все ее зависимости, например #r "myLib.dll".</value>
  </data>
  <data name="LoadHelp" xml:space="preserve">
    <value>Загрузите указанный файл скрипта и выполните его, например #load "myScript.csx".</value>
  </data>
</root>